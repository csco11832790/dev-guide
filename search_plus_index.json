{"./":{"url":"./","title":"开发指引","keywords":"","body":"开发指引 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具.html":{"url":"开发工具.html","title":"开发工具","keywords":"","body":"开发工具介绍 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/sourcetree.html":{"url":"开发工具/sourcetree.html","title":"SourceTree","keywords":"","body":" 请参考:Git-Flow/petrel分支版本管理 http://wiki.wonhigh.cn:8090/pages/viewpage.action?pageId=24879129 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/intellij-idea.html":{"url":"开发工具/intellij-idea.html","title":"Intellij IDEA","keywords":"","body":"Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/公共问题.html":{"url":"开发工具/公共问题.html","title":"公共问题","keywords":"","body":"Jdk问题 * > Couldn't create AES/GCM/NoPadding cipher: Illegal key size * 解决办法![](/assets/jdk问题.png) host域名问题 settings.xml问题 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/代码生成器.html":{"url":"开发工具/代码生成器.html","title":"代码生成器","keywords":"","body":"引入代码生成器 src/test/java/codegenerator/BaseTypeEnum.java src/test/java/codegenerator/CodeGenerator.java src/test/resources/templates 代码说明 BaseTypeEnum: 类型选择枚举类，目前可继承基类的三种类型单表、多表以及单据 CodeGenerator: 代码生成器入口 生成器模板 使用规则 修改具体工程对应的packageName String packageName = \"com.belle.bms.chargingsys.core\"; 填写对应需要生成的表名，多个表用逗号隔开 generateByTables(packageName, 0, \"bm_carrier\",\"xx\",\"xx\"); 修改数据库链接及用户名、密码 String dbUrl = \"jdbc:mysql://10.0.30.39:3306/db_bms_cs?useUnicode=true&characterEncoding=utf-8&useSSL=false\"; DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDbType(DbType.MYSQL) .setUrl(dbUrl) .setUsername(\"user_bms_cs\" ) .setPassword(\"scm_bms_cs\" ) .setDriverName(\"com.mysql.jdbc.Driver\" ); 修改生成代码的用户名 config.setActiveRecord(false) .setIdType(tableIdType) .setAuthor(\"zhang.mj\" ) 修改实体继承对象 .setSuperEntityClass(\"com.belle.petrel.common.base.entity.AbstractEntity\" );//修改替换成你需要的类名AbstractEntity/BaseEditEntity 设置代码生成的文件存放路径 config.setActiveRecord(false) .setIdType(tableIdType) .setAuthor(\"zhang.mj\" ) .setBaseResultMap(true) .setBaseColumnList(false) .setOutputDir(\"/Users/liqi/code/belle/codegen\" ) 去对应目录将生成的文件拷贝到项目对应的目录中 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/Mapstruct工具.html":{"url":"开发工具/Mapstruct工具.html","title":"Mapstruct工具","keywords":"","body":"Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发工具/jenkins使用指引.html":{"url":"开发工具/jenkins使用指引.html","title":"jenkins使用指引","keywords":"","body":"发版指引 后端应用(初次发版，需要配置jenkins及上传配置文件) gitlab上建立标准后端工程 jenkins配置应用构建模板 地址：http://10.0.43.24:10080/ user/pwd:deployer/deployer copy后端应用jenkins配置模板 配置git 修改应用git地址 使用http地址，配合git账号使用 配置maven 替换应用名，注意需要使用工程对应的api层名称 构建后操作配置 替换应用名 新增配置文件 向运维申请服务器及端口 根据运维分配的端口，修改本地yml配置文件 将本地yml配置文件copy一份，并上传至gitlab配置仓库 编译、打包成镜像，并发布至开发环境 填写需要发版的分支 填写发版分支对应的版本号 后端工程(开发分支常规发版) 编译、打包镜像，并发布至开发环境 填写需要发版的分支 填写发版分支对应的版本号 后端工程(测试分支常规发版) 运行job升级版本 编译、打包镜像，并发布至开发环境 填写需要发版的分支 填写发版分支对应的版本号 前端工程(初次发版，需要配置jenkins) gitlab上建立标准前端工程 jenkins配置工程构建模板 copy前端工程jenkins配置模板 配置git 配置maven 编译、打包成镜像，并发布至开发环境 填写需要发版的分支 填写发版分支对应的版本号 UC挂模块(首次挂载) 新建项目(图标可另外上传) 新建资源 新建用户 新建角色 给用户分配角色 给角色分配资源 菜单上给该项目挂载资源 UC挂模块(常规挂载) 新增资源 菜单上给对应项目挂载资源 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务.html":{"url":"公共服务.html","title":"公共服务","keywords":"","body":"通用基础组建介绍 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/编码规则服务.html":{"url":"公共服务/编码规则服务.html","title":"编码规则服务","keywords":"","body":"使用场景 后端生成单据时，取单据编号 引入依赖 ``` xml com.belle petrel-itg-client 1.0.0-SNAPSHOT ``` 取单号接口 @RequestMapping(value = \"/itg/api/sysCodeRule/getSheetIdCode.json\", method = RequestMethod.GET) public String getSystemCode(@RequestParam(value = \"codeRuleNo\") String codeRuleNo); 取单据号接口使用 引入取单号服务 @Autowired private SysCodeRuleApi sysCodeRuleApi; 调用接口获取对应业务单据的单据号 批量取单号服务 ... Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/字典服务.html":{"url":"公共服务/字典服务.html","title":"字典服务","keywords":"","body":"数据字典 前后端交互 http接口说明 /itg/api/sysDictDtl/findSysDict.json 根据字典编码取对应名称, 多用于前端下拉框取数据源 工程间调用 引入依赖 com.belle petrel-itg-client 1.0.0-SNAPSHOT feign接口说明 /**查询字典明细表, * @param columnMap:根据字典主表字段dict_code,以及明细表的status(启用/禁用状态)查询 * */ @RequestMapping(value = \"/itg/api/basDictCodeDtlTypeApi/findSysDict.json\", method = RequestMethod.POST) public List findSysDict(@RequestBody Map columnMap); 使用方法 注入feign接口 @Autowired private ItgCodeTypeApi itgCodeTypeApi; 调用接口方法，查询字典数据 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/文件服务.html":{"url":"公共服务/文件服务.html","title":"文件服务","keywords":"","body":"文件服务 使用场景 目前mongoDb主要用于导出文件存放以及图片上传下载，例如用户头像上传等 上传文件 配置文件上传相关参数 drop table if exists sys_bucket_config; create table sys_bucket_config ( id bigint not null comment 'ID', code varchar(64) not null comment '编号', //业务编号 如：BMS name varchar(64) not null comment '名称', //业务名称 如：合同文件 value varchar(64) not null comment '集合名称,存储到Mongodb的表名', suffix varchar(64) default '*.*' comment '支持的文件后缀格式: *.pdf,*.gif,*.pmp', //默认为所有类型的文件 file_size bigint comment '文件大小,已kb为单位', //限制最大上传文件大小 status tinyint default 1 comment '状态，1是启用，0是禁用', creator varchar(20) not null comment '建档人', create_time datetime not null comment '建档时间', modifier varchar(20) comment '最后修改人', modify_time datetime comment '最后修改时间', remarks varchar(255) comment '备注', constraint pk_sys_bucket_config primary key(id), constraint unique_sys_bucket_config unique(code) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 comment = '集合配置'; 前端调用上传接口 接口地址 http://10.0.43.18:20041/file/upload/CG001 html demo CG001参数为上一步中维护的code 接口返回格式 上传文件返回结果： { \"flag\": { \"retCode\": \"0\", \"retMsg\": \"success\" }, \"data\": [ { \"fileId\": \"5c050b32dbe31639e6ca1ee6\", \"fileName\": \"测试文件上传.xlsx\", \"fileSize\": \"23504\", \"fileMD5\": \"932630b254cd55377286ba9f9078c6b7\", \"fileUploadDate\": \"2018-12-03 18:53:38\" } ] } 前端拿到fileId后，填充实体中的图片url，并向后端请求实体保存接口 多文件上传demo例子待前端集成后组件方可使用 文件下载 前端发起下载文件请求 请求链接 http://10.0.43.18:20041/file/download/CG001/5bff5611473dd20689ab8455 CG001: 维护的code 5bff5611473dd20689ab8455: 上传时返回并存入实体url字段的fieldId Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/redis服务.html":{"url":"公共服务/redis服务.html","title":"Redis服务","keywords":"","body":"Redis 使用场景： 基础数据缓存 数据权限缓存 常用热点数据缓存 core层引入redis依赖 com.belle petrel-redis-core redis工具类 JdkRedisOperationsService 序列化java对象，且被序列化的对象必须实现Serializable接口 StringRedisOperationsService 简单的字符串序列化。一般如果key-value都是string的话，使用该工具类 使用方法举例 引入redis服务 @Autowired private JdkRedisOperationsService jdkRedisOperationsService; 取对象demo String cacheKey = \"petrel:itg:sys.dict.dtl:find.list\"; String hKey = columnMap == null ? \"all\" : columnMap.toString(); // columnMap为Map结构的查询条件 List list = null; if (JdkRedisOperationsService != null) { list = (List)JdkRedisOperationsService.hashOpsGet(cacheKey, hKey); if (CommonUtil.isNotNull(list)) { return list; } } 存对象demo String cacheKey = \"petrel:itg:sys.dict.dtl:find.list\"; String hKey = columnMap == null ? \"all\" : columnMap.toString(); List resultList = this.baseService.selectByMap(columnMap); // columnMap为Map结构的查询条件 if (JdkRedisOperationsService != null && CommonUtil.isNotNull(resultList)) { JdkRedisOperationsService.hashOpsPut(cacheKey, hKey, resultList,30L,DAYS); // 缓存30天 } 使用规范 key名设计 遵循可读性和可管理性 key=项目工程名称+微服务名称＋业务名＋业务数据＋XXX，用冒号分隔，多个连接单词用英文\".\"连接，如：petrel:itg:sys.dict.dtl:find.list key名要简洁，且不要包含特殊字符 控制key的长度，当key较多时，内存占用也不容忽视 控制key的生命周期，key的过期时间根据具体业务确定，做到精确设置，所有key必须设置expire，必须设置，不然后果很严重哦~ value设计 控制值大小，为避免大key的产生，value值存储尽量精简，减小内存开支 选择合适的数据类型 常规缓存方案指引 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/导入服务.html":{"url":"公共服务/导入服务.html","title":"导入服务","keywords":"","body":"导入 导入流程说明 前端请求导入中心 导入中心解析excel，并根据url参数，请求具体的业务工程接口 业务工程进行数据校验等处理，持久化数据库 导入参数说明(ImportReqDataVO) colNames: 字段名称，类实体字段名称,对应excel里导入的列 mustArray: 哪些字段是必须的,非必须可允许为空 mainKey: 表唯一约束 mainKeyName: 表唯一约束名称 validateAll: 是否验证所有数据成功,才允许导入 masterFields: 用于从表导入,需要主表关联字段的值 dataList: 数据源 async: 是否异步导入 url: 导入服务写数据url地址 前端开发demo 前端导入上传文件地址 https://dev-petrel.belle.net.cn/petrel/petrel-export-center-api/importCenter/import 前端传参 url: 导入服务写数据url地址(eg:http://dev-petrel.belle.net.cn/priv/api/sysDataPrivilegeDtl/importData) masterFields(导入多表的明细表数据时，必传参数。 eg:[{\\\"field\\\":\\\"privilegeId\\\",\\\"value\\\":\\\"G01\\\"}]) 后端开发demo 服务层最少需要继承BaseSimplePageService 服务层重写beforeImportData方法，设置必要参数 demo /** * 重写导入前方法 * @param importResolveVO * @param systemUser */ @Override protected void beforeImportData(ImportReqDataVO importResolveVO, SystemUser systemUser) { super.beforeImportData(importResolveVO, systemUser); // 设置与excel对应的列 importResolveVO.setColNames(\"resourceId,tableName,columnName\"); // 设置表结构的联合唯一约束 importResolveVO.setUnionKey(\"privilegeId,resourceId,tableName,columnName\"); // 违反联合唯一索引时错误信息中的约束名 importResolveVO.setUnionKeyName(\"数据权限明细唯一约束\"); // 设置对应excel中列是否允许为空 importResolveVO.setMustArray(\"true,true,true\"); // 设置是否校验所有导入的数据 importResolveVO.setValidateAll(true); } Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/导出服务.html":{"url":"公共服务/导出服务.html","title":"导出服务","keywords":"","body":"导出 导出数据流说明 前端发请求到导出服务 导出服务解析findUrl及参数searchData、pageNum、pageSize，去对应的应用请求数据 将请求的数据写入excel存入mongodb，并写通知 前端页面打开通知面板，下载文件 DEMO 请求类型： POST 测试URLhttps://dev-petrel.belle.net.cn/petrel/petrel-export-center-api/exportCenter/export 参数{ \"exportColumns\": [{ \"field\": \"userName\", \"title\": \"用户名\", \"width\": 120 }, { \"field\": \"projectId\", \"title\": \"编号\", \"width\": 120 }, { \"field\": \"projectName\", \"title\": \"项目名称\", \"width\": 120 }, { \"field\": \"companyName\", \"title\": \"集团名称\", \"width\": 120 }], \"exportCombos\": { \"projectId\": { \"textFiled\": \"text\", \"valeFiled\": \"id\", \"comboData\": [{ \"id\": \"1\", \"text\": \"启用\" }, { \"id\": \"0\", \"text\": \"禁用\" }] }, \"enableFlag\": { \"textFiled\": \"text\", \"valeFiled\": \"id\", \"comboData\": [{ \"id\": \"1\", \"text\": \"启用\" }, { \"id\": \"0\", \"text\": \"禁用\" }] } }, \"fileName\": \"export\", \"findUrl\": \"https://dev-petrel.belle.net.cn/petrel/petrel-priv-api/priv/api/sysUserProject/find.json\", \"searchData\": \"search.e.loginName_like=sds\", \"pageNum\": 1, \"pageSize\": 25, \"exportFileFormat\": \"xlsX\", \"requestMethodType\":\"GET\" } 参数说明 fileName 导出文件名称 findUrl 导出数据查询url searchData 导出数据查询参数 pageNum/pageSize 数据分页情况,不传代表查询所有 exportFileFormat 导出格式,默认:xlsx compress是否压缩，默认不压缩 templateId暂时可不填,预留使用 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/xxl-job调度.html":{"url":"公共服务/xxl-job调度.html","title":"xxl-job调度","keywords":"","body":"调度平台 引入依赖 com.belle petrel-schedule-client 1.0.0-SNAPSHOT 添加配置 xxl: job: executor: #本地日志存放路径 logpath: /Users/liqi/logs/xxl/ #执行器 appname: xxl-job-executor-sample2 port: 9999 logretentiondays: -1 ip: admin: #调度中心地址 addresses: http://10.0.43.18:10010 accessToken: 调度任务开发 开发步骤 1、继承\"IJobHandler\"：“com.xxl.job.core.handler.IJobHandler”； 2、注册到Spring容器：添加“@Component”注解，被Spring容器扫描为Bean实例； 3、注册到执行器工厂：添加“@JobHandler(value=\"自定义jobhandler名称\")”注解，注解value值对应的是调度中心新建任务的JobHandler属性的值。 4、执行日志：需要通过 \"XxlJobLogger.log\" 打印执行日志； 代码demo /** * Created by liqi on 2018/12/4. */ @JobHandler(value = \"lqJobHandler\") @Component public class LqJobHandler extends IJobHandler { @Autowired private BmCarrierService bmCarrierService; /** * 具体的任务功能说明 * @param param 用于接收页面维护的参数 * @return * @throws Exception */ @Override public ReturnT execute(String param) throws Exception { XxlJobLogger.log(\"Begin schedule\"); EntityWrapper entityWrapper = new EntityWrapper<>(); entityWrapper.eq(\"del_tag\", 0).last(\"limit 10\"); // 按del_flag=0 每次查询10条更新状态 List list = bmCarrierService.selectList(entityWrapper); for (BmCarrier bmCarrier : list) { bmCarrier.setDelTag(1); } bmCarrierService.updateBatchById(list); XxlJobLogger.log(\"Begin end\"); return SUCCESS; } } 新增执行器(每个工程配置一个执行器) 本地服务启动后，会显示在线机器 新增定时任务 执行器：选择上一步中维护的对应的执行器 JobHandler：编写的具体调度服务(注解[@JobHandler(value = \"lqJobHandler\")] 中的value值) corn：标准corn表达式   请参考:调度开发 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"公共服务/返回参数封装.html":{"url":"公共服务/返回参数封装.html","title":"返回参数封装","keywords":"","body":"结果封装 接口返回结果统一使用工具类ResultMapUtils petrel-common 1.0.1-SNAPSHOT及以上版本支持 弃用原工具类WebUtils 方法说明 /** * 获取默认的resultMap * * @return */ public static Map getSuccessResultMap() { Map resultMap = Maps.newHashMap(); ResultVO flag = new ResultVO(); flag.setRetMsg(\"success!\"); resultMap.put(ResultConstants.FLAG, flag); return resultMap; } /** * 返回带成功信息的resultMap * @param successMsg * @return */ public static Map getSuccessResultMap(String successMsg) { Map resultMap = Maps.newHashMap(); ResultVO flag = new ResultVO(); flag.setRetMsg(successMsg); resultMap.put(ResultConstants.FLAG, flag); return resultMap; } /** * 返回带错误信息的resultMap * @param errorMsg * @return */ public static Map getErrorResultMap(String errorMsg) { Map resultMap = new HashMap<>(); ResultVO flag = new ResultVO(); flag.setRetCode(ResultVO.ERROR_CODE); if (StringUtils.isNotBlank(errorMsg)) flag.setRetMsg(errorMsg); resultMap.put(ResultConstants.FLAG, flag); return resultMap; } /** * 返回带错误编码、错误信息的resultMap * @param errCode * @param errorMsg * @return */ public static Map getErrorResultMap(String errCode, String errorMsg) { Map resultMap = new HashMap<>(); ResultVO flag = new ResultVO(); flag.setRetCode(errCode); if (StringUtils.isNotBlank(errorMsg)) flag.setRetMsg(errorMsg); resultMap.put(ResultConstants.FLAG, flag); return resultMap; } /** * 返回带错误编码、错误信息、错误信息明细的resultMap * @param errCode * @param errorMsg * @param detailMessage * @return */ public static Map getErrorResultMap(String errCode, String errorMsg, String detailMessage) { Map resultMap = new HashMap<>(); ResultVO flag = new ResultVO(); flag.setRetCode(errCode); if (StringUtils.isNotBlank(errorMsg)) flag.setRetMsg(errorMsg); if (StringUtils.isNotBlank(detailMessage)) flag.setRetDetail(detailMessage); resultMap.put(ResultConstants.FLAG, flag); return resultMap; } Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板.html":{"url":"开发模板.html","title":"开发模板","keywords":"","body":"常用开发模板 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/实体&表结构.html":{"url":"开发模板/实体&表结构.html","title":"实体&表结构","keywords":"","body":"entity&表结构 注解 @TableName(\"sys_dict_dtl\") // 映射数据库表名 @Getter // lombok插件注解 生成get方法 @Setter // lombok插件注解 生成set方法 @ToString // lombok插件注解 生成toString方法 继承关系 单表、多表 继承AbstractEntity即可 单据继承表继承BaseEditEntity(增加了单据相关字段) 表名命名规则参考阳磊整理的数据库规范文档 常见问题 question1: 数据库id字段写数据时未生成全局唯一ID 实体类里 idType=ID_WORKER @TableId(value = \"id\", type = IdType.ID_WORKER) private Long id; 实体里的getId不能返回null @Override public Long getId() { // TODO Auto-generated method stub return this.id; } 检查mybatis配置文件 #主键类型 0:\"数据库ID自增\", 1:\"用户输入ID\",2:\"全局唯一ID (数字类型唯一ID)\", 3:\"全局唯一ID UUID\"; id-type: 0 检查表结构的id字段是否误设置为自增 id bigint not null comment 'ID' Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/单表开发模板.html":{"url":"开发模板/单表开发模板.html","title":"单表开发模板","keywords":"","body":"单表开发 单表维护模块前端界面模型，实现单表的增删改查功能 单表基类继承 继承BaseSimplePageController 通用的业务开发自定义的controller ... 前端请求参数封装格式 新增 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysCompany/simple_add.json { \"address\":\"测试地址\", \"code\":\"Ctest\", \"status\":1, \"linkman\":\"测试联系人\", \"name\":\"测试公司\", \"workPhone\":\"13923232323\", \"remarks\":\"\" } 修改 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysProject/simple_update.json { \"address\":\"测试地址\", \"code\":\"Ctest\", \"status\":1, \"linkman\":\"测试联系人\", \"name\":\"测试公司\", \"workPhone\":\"13923232323\", \"remarks\":\"test\" } 删除 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysCompany/simple_delete.json 参数：tableId: 1067702981834747906 查询 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysProject/find.json?search.code_like=test&search.name_like=test&page.pn=1&page.size=10 单表常用基类方法(继承基类后，即可使用，无需额外编码) /simple_add.json 简单保存 /simple_delete.json 简单删除 /simple_update.json 简单更新 /find.json 分页查询 返回分页数据 /findVOAll.json 不分页查询所有数据 返回所有数据集合 /findOne.json 按主键查询 返回对应实体 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/多表开发模板.html":{"url":"开发模板/多表开发模板.html","title":"多表开发模板","keywords":"","body":"多表开发 多表维护模块前端界面模型，实现多表的增删改查功能 多表基类继承 继承BaseMultiPageController 通用的业务开发自定义的controller ... 前端请求参数封装格式 新增 保存主表 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysDict/multi_add.json { \"dictCode\":\"test\", \"dictName\":\"测试\", \"status\":1 } 保存从表 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysDictDtl/simple_add.json { \"itemCode\":\"test1\", \"itemName\":\"测试1\", \"status\":1, \"dictId\":\"1067716634390736898\" } 修改(主从表分开修改) https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysDictDtl/simple_update.json { \"id\":\"1067716933369114626\", \"dictId\":\"1067716634390736898\", \"itemCode\":\"test1\", \"itemName\":\"测试2\", \"status\":1, \"creator\":\"admin\", \"createTime\":\"2018-11-28 17:48:49\", \"modifier\":\"admin\", \"modifyTime\":\"2018-11-28 17:51:51\" } 删除(多表删除，会将主从表一起删除) https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysDict/multi_delete.jsonn 参数：tableId: 1067716634390736898 查询 https://st-petrel.belle.net.cn/petrel/petrel-itg-api/itg/api/sysDict/find.json?search.dictCode_like=res_group&page.pn=1&page.size=10 多表常用基类方法(继承基类后，即可使用，无需额外编码) /multi_add.json 主表保存 /multi_delete.json 多表删除 /simple_add.json 简单保存 /simple_delete.json 简单删除 /simple_update.json 简单更新 /find.json 分页查询 返回分页数据 /findVOAll.json 不分页查询所有数据 返回所有数据集合 /findOne.json 按主键查询 返回对应实体 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/单据开发模板.html":{"url":"开发模板/单据开发模板.html","title":"单据开发模板","keywords":"","body":"Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/多种接口参数形式说明.html":{"url":"开发模板/多种接口参数形式说明.html","title":"多种接口参数形式说明","keywords":"","body":"接口方法参数接收的几种方式 page+map page+vo对象 page+entitywrapper demo: controller层: /** * * 承运商信息 前端控制器 * * * @author zhang.mj * @since 2018-11-30 */ @FeignRestController @RequestMapping(\"/bmCarrier\") @Api(tags = {\"多参数类型DEMO\"}) public class BmCarrierController extends BaseSimplePageController { @Autowired private BmCarrierService service; @Override protected void init() { setBaseService(service); //设置VO实体 //setMainVOClazz(UcUser.class); } /** * Map形式传参demo * * 关于接收参数使用@RequestParam、@RequestBody的说明 * RequestParam，接收的参数是来自于链接中拼接的参数 * RequestBody，接收的参数是来自于requestBody，即请求体中 * * 请求链接： * http://localhost:31003/bmCarrier/carrier?page.pn=1&page.size=10 * &carrierNo=1&carrierName=a&carrierType=1 * &createTime=2018-11-30 12:12:32 * * @param page * @param params * @return */ @ApiOperation(value = \"Map形式传参demo\", httpMethod = \"GET\", notes = \"carrierNo=c01, carrierName like 测试, carrierType=1\") @GetMapping(value = \"/carrier\") public Map testMapParameter(Page page, @RequestParam Map params){ //检查参数 if (params.get(\"carrierNo\") == null || params.get(\"carrierName\") == null || params.get(\"carrierType\") == null) { throw new MyselfMsgException(\"参数不完整！\"); } // 定义返回结果 Map resultMap = WebUtils.getDefaultResultMap(); // 两种形式 // 1.将参数放入entityWrapper，利用${ew.sqlSegment} 让mybatis plus自动解析 // 2.将map参数整个传入，在xml中手工解析 //此处采用第一种方式 EntityWrapper entityWrapper = new EntityWrapper<>(); entityWrapper.eq(\"carrier_no\", params.get(\"carrierNo\").toString()); entityWrapper.like(\"carrier_name\", params.get(\"carrierName\").toString()); entityWrapper.eq(\"carrier_type\", Integer.valueOf(params.get(\"carrierType\").toString())); // 调用基类分页查询方法 Page bmCarriers = service.selectPage(page, entityWrapper); // 填充并返回结果集 resultMap.put(ResultConstants.ROWS, bmCarriers.getRecords()); resultMap.put(ResultConstants.TOTAL, page.getTotal()); return resultMap; } /** * VO形式传参demo * * 请求链接： * http://localhost:31003/bmCarrier/carrier2?page.pn=1&page.size=10 * &carrierName=t&carrierType=1 * * tip1：GET请求，实体接收参数时，不能加@RequestParam * * tip2：GET请求，实体接收参数时，日期类型转换会出错，即vo里面不能传日期相关的字段当做条件 * 解决办法： * 在controller里增加以下方法 * @InitBinder * public void initBinder(WebDataBinder binder) { * SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); // 日期格式自己定义 * binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false)); * } * * @param page * @param bmCarrierVO * @return */ @ApiOperation(value = \"VO形式传参demo\", httpMethod = \"GET\") @GetMapping(value = \"/carrier2\") public Map testVoParameter(Page page, BmCarrierVO bmCarrierVO){ // 定义返回结果 Map resultMap = WebUtils.getDefaultResultMap(); // 两种形式 // 1.将参数从vo中get出来，放入entityWrapper中，利用${ew.sqlSegment} 让mybatis plus自动解析 // 2.将vo整体传递，在xml中手工解析 //此处采用第二种方式 Page bmCarriers = service.selectPageByVO(page, bmCarrierVO); // 填充并返回结果集 resultMap.put(ResultConstants.ROWS, bmCarriers.getRecords()); resultMap.put(ResultConstants.TOTAL, page.getTotal()); return resultMap; } /** * EntityWrapper形式传参demo * * 请求链接： * http://localhost:31003/bmCarrier/carrier3?page.pn=1&page.size=10 * &search.carrierName_like=t&search.carrierType_eq=1 * &search.createTime_eq=2018-11-30 12:12:32 * * @param page * @param entityWrapper * @return */ @ApiOperation(value = \"EntityWrapper形式传参demo\", httpMethod = \"GET\") @GetMapping(value = \"/carrier3\") public Map testWrapperParameter(Page page, EntityWrapper entityWrapper){ // 定义返回结果 Map resultMap = WebUtils.getDefaultResultMap(); // 调用基类查询方法 Page bmCarriers = service.selectPage(page, entityWrapper); // 填充并返回结果集 resultMap.put(ResultConstants.ROWS, bmCarriers.getRecords()); resultMap.put(ResultConstants.TOTAL, page.getTotal()); return resultMap; } } service层 /** * * 承运商信息 服务类 * * * @author zhang.mj * @since 2018-11-30 */ public interface BmCarrierService extends BaseService { /** * VO形式传参demo * @param page * @param vo * @return */ Page selectPageByVO(Page page, BmCarrierVO vo); } mapper层 /** * * 承运商信息 Mapper 接口 * * * @author zhang.mj * @since 2018-11-30 */ public interface BmCarrierMapper extends BaseCrudMapper { /** * VO形式传参demo * @param page * @param vo * @return */ Page selectPageByVO(Page page, BmCarrierVO vo); } mapper.xml AND carrier_no = #{carrierNo,jdbcType=VARCHAR} AND carrier_name = #{carrierName,jdbcType=VARCHAR} AND carrier_type = #{carrierType,jdbcType=INTEGER} SELECT carrier_no, carrier_name, carrier_type, contacts_man, contacts_phone, status, del_tag, creator, create_time, modifier, modify_time FROM bm_carrier WHERE 0 &lt;&gt; 1 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/api开发模板.html":{"url":"开发模板/api开发模板.html","title":"Api开发模板","keywords":"","body":"api开发规范(api层) 使用场景：用于前后端交互，前端请求入口 接口定义规范 @RestController @RequestMapping(\"/itg/api/sysNotice\") @Api(tags = {\"公告服务\"}) 服务引入及命名建议 @Autowired private SysNoticeService service; // 模块本身服务引入统一叫service @Autowired private SysPrivApi sysPrivApi; // 相关服务引入名称采用驼峰命名，且与类名保持一致 接口方法注解使用建议 @ApiOperation(value = \"查询用户权限\", httpMethod = \"POST\") // 接口功能说明 @PostMapping(value = \"/findSysUserPermission.json\") // 用特定的注解标明该接口的http请求方式 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/client开发模板.html":{"url":"开发模板/client开发模板.html","title":"Client开发模板","keywords":"","body":"feign开发规范(client层) 使用场景：用于工程间的调用 提供方定义好接口，需要将jar包打包上传 使用方需要引用该client jar包，再使用里面的接口 jar包打包上传命令：mvn clean source:jar deploy -Dmaven.test.skip=true -U -X feign接口定义 @FeignClient( name = Providers.PETREL_ITG_API, // 提供者名称 fallbackFactory = ItgCodeTypeApiFallbackFactory.class // 回调类名 ) 接口命名 ItgCodeTypeApi 以api结尾 接口方法定义及注意事项 /**查询字典主表, * @param columnMap:根据字典明细的数据库字段,进行查询,map为空则查全部 * */ @RequestMapping(value = \"/itg/api/basDictCodeTypeApi/cache/findList.json\", method = RequestMethod.POST) public List findList(@RequestBody Map columnMap); tips: RequestMapping的路径对应api层controller的路径 method定义的http协议与controller里的定义保持一直 使用@RequestBody接收对象参数，@RequestParam接收多个平铺的参数 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/多表关联查询.html":{"url":"开发模板/多表关联查询.html","title":"多表关联查询","keywords":"","body":"Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-11 17:10:39 "},"开发模板/国际化.html":{"url":"开发模板/国际化.html","title":"国际化","keywords":"","body":"国际化 核心思想 对需要提供多语言的业务，新建一张多语言表，将需要多语言的字段放入该表中 保存数据时，将需要多语言的字段存入对应的语言表 修改数据时，根据语言类型，修改对应的语言表记录 删除数据时，同时删除语言表数据 查询数据时，根据前端请求头里带的语言类型，从多语言表中取出相应的值，替换默认表 前端请求链接的Cookie里带上语言类型lan=en-US/zh-cn/zh-tw/zh-ja 表结构设计 /* * sys_project 产品表 */ drop table if exists sys_project; create table sys_project ( id bigint not null comment 'ID', code varchar(20) not null comment '产品编码', name varchar(64) not null comment '产品名称', home_url varchar(64) comment '首页URL', gateway_url varchar(64) comment '网关URL', big_icon varchar(128) comment '大图标', small_icon varchar(128) comment '小图标', status tinyint default 1 comment '状态', creator varchar(20) not null comment '建档人', create_time datetime not null comment '建档时间', modifier varchar(20) comment '最后修改人', modify_time datetime comment '最后修改时间', remarks varchar(255) comment '备注', constraint pk_sys_project primary key(id), constraint unique_sys_project unique(code) )ENGINE=InnoDB DEFAULT CHARSET=utf8 comment='项目表'; -- 项目多语言表 drop table if exists sys_project_language; create table sys_project_language ( id bigint not null comment 'ID', project_id bigint not null comment '项目ID', project_name varchar(64) not null comment '项目名称', language_type varchar(20) not null comment '语言类型', -- 数据字典 （zh-cn=中文 zh-tw=繁体 en=英文 ja=日语） remarks varchar(255) comment '备注', constraint pk_sys_project_language primary key(id), constraint unique_sys_project_language unique(project_id,language_type) )ENGINE=InnoDB DEFAULT CHARSET=utf8 comment='项目多语言表'; 使用方法 新增、修改、删除 service层引入多语言服务 @Autowired private SysProjectLanguageMapper sysProjectLanguageMapper; service层重写simpleSave方法(用于处理新增修改)、beforeDelete(用于处理删除) /** * 重写，处理多语言 * @param reqData * @param systemUser * @param fieldMap * @throws IOException */ @Override protected void simpleSave(SimpleSaveRequest reqData, SystemUser systemUser, Map fieldMap) throws IOException { List listInsertRows = null; List listUpdateRows = null; List listDeleteRows = null; String opByOther = \"\"; boolean confirmable; if (CommonUtil.isNotNull(reqData.getInsertRows())) { listInsertRows = reqData.getInsertRows(); listInsertRows = this.parseListBean(listInsertRows, this.entityClass); confirmable = this.beforeInsert(listInsertRows, systemUser); if (confirmable) { this.getProxyService().insertBatch(listInsertRows, listInsertRows.size()); } listInsertRows.forEach(insert -> { SysProjectLanguage language = this.changeToSysProjectLanguage(insert); sysProjectLanguageMapper.insert(language); }); } if (CommonUtil.isNotNull(reqData.getUpdateRows())) { listUpdateRows = reqData.getUpdateRows(); listUpdateRows = this.parseListBean(listUpdateRows, this.entityClass); confirmable = this.beforeUpdate(listUpdateRows, systemUser); if (confirmable) { Iterator var10 = listUpdateRows.iterator(); while (var10.hasNext()) { SysProject t = (SysProject) var10.next(); this.getProxyService().updateByIdNames(t, fieldMap, opByOther); } } listUpdateRows.forEach(update -> { SysProjectLanguage language = this.changeToSysProjectLanguage(update); EntityWrapper ew = new EntityWrapper(); ew.eq(\"project_id\", update.getId()); ew.eq(\"language_type\", MessageUtils.getLocaleStr()); Integer integer = sysProjectLanguageMapper.selectCount(ew); if (integer != null && integer > 0) { sysProjectLanguageMapper.update(language, ew); } else { sysProjectLanguageMapper.insert(language); } }); } if (CommonUtil.isNotNull(reqData.getDeleteRows())) { confirmable = Confirmable.class.isAssignableFrom(this.entityClass); listDeleteRows = reqData.getDeleteRows(); boolean flagDelete = this.beforeDelete(listDeleteRows, systemUser); AbstractEntity entity; if (flagDelete) { for (Iterator var15 = listDeleteRows.iterator(); var15.hasNext(); this.getProxyService().deleteByIdNames(entity, fieldMap, opByOther)) { Object t = var15.next(); entity = this.parseBean(t, this.entityClass); if (confirmable) { if (((Confirmable) entity).isConfirmed()) { throw new MyselfMsgException(MessageUtils.message(\"base.simple.page.data.affirm\", new Object[]{entity.getId()})); } opByOther = StringUtils.isEmpty(opByOther) ? \"confirmFlag\" : \",confirmFlag\"; } } } } } /** * 重写删除，处理多语言 * @param list * @param user * @return */ @Override public boolean beforeDelete(List list, SystemUser user) { List collect = list.stream().map(SysProject::getId).collect(Collectors.toList()); EntityWrapper ew = new EntityWrapper(); ew.in(\"project_id\", collect); ew.eq(\"language_type\", MessageUtils.getLocaleStr()); sysProjectLanguageMapper.delete(ew); return true; } /** * 处理多语言保存、修改 * @param sysProject * @return */ private SysProjectLanguage changeToSysProjectLanguage(SysProject sysProject) { SysProjectLanguage language = new SysProjectLanguage(); language.setProjectId(sysProject.getId()); language.setProjectName(sysProject.getName()); language.setLanguageType(MessageUtils.getLocaleStr()); language.setRemarks(sysProject.getRemarks()); return language; } 查询 controller层 注入对应多语言表服务 @Autowired private SysProjectLanguageService sysProjectLanguageService; 重写基类分页查询方法 /** * 分页查询项目信息 * @param page * @param entityWrapper * @return */ @RequestMapping(value = \"/find.json\", method = {RequestMethod.GET, RequestMethod.POST}) @ResponseBody public Map find(Page page, EntityWrapper entityWrapper) { Map resultMap = WebUtils.getDefaultResultMap(); Page pageList = this.baseService.selectPage(page, entityWrapper); List records = pageList.getRecords(); sysProjectLanguageService.changeLanguage(records); resultMap.put(ResultConstants.ROWS, pageList.getRecords()); resultMap.put(ResultConstants.TOTAL, pageList.getTotal()); return resultMap; } 多语言服务层(注意是多语言表的服务层，默认表的服务层不用处理) @Override public List changeLanguage(List sysProjects) { if (sysProjects != null && !sysProjects.isEmpty()) { Map map = new HashMap<>(1); map.put(\"language_type\",MessageUtils.getLocaleStr()); List sysProjectLanguages = basMapper.selectByMap(map); sysProjects.forEach(sysProject -> { sysProjectLanguages.forEach(sysProjectLanguage -> { if (sysProjectLanguage.getProjectId().equals(sysProject.getId()) && sysProjectLanguage.getLanguageType().equals(MessageUtils.getLocaleStr())) { sysProject.setName(sysProjectLanguage.getProjectName()); sysProject.setRemarks(sysProjectLanguage.getRemarks()); } } ); }); } return sysProjects; } 自定义异常国际化处理 各语言配置文件中自定义异常信息 petrel-itg/petrel-itg-api/src/main/resources/i18n/messages_en_US.properties自定义异常信息: test.error.message=Test error message petrel-itg/petrel-itg-api/src/main/resources/i18n/messages_zh_CN.properties自定义异常信息: test.error.message=测试错误信息 petrel-itg/petrel-itg-api/src/main/resources/i18n/messages_zh_TW.properties自定义异常信息: test.error.message=測試錯誤信息 测试接口 @RestController @RequestMapping(value = \"/test\") public class TestLanguage { @GetMapping(\"/language\") public Map test(){ return ResultMapUtils.getErrorResultMap(MessageUtils.message(\"test.error.message\")); } } postman测试结果 中文 繁体中文 英文 Copyright © IQ 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-12-12 11:03:47 "}}